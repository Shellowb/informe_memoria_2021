
    Creación del Handler
    En el sistema anterior todos los comandos tenían su propio bloque de código, principalmente porque solo enviaban mensajes de texto de vuelta al sistema.
    En el nuevo sistema se deja la tarea de determinar que acción tomar a un Handler. Hay dos grandes diferencias entre el parser y handler (porque ambos funcionan como un parser).
    La primera es que el Handler se hace cargo de la lógica específica de cada acción de manera standard, es decir una vez que identifica la expresión de texto, llama a un objeto que contiene la acción a realizar. Uno de los mayores beneficios es que se puede ver claramente cual es árbol de decisión o el camino de la acción sin entrar en la acción particular, a la vez que permite que las acciones se puedan modificar o extender sin cambiar el llamado standar de los objetos. También hace sencillo extender la funcionalidad. 
    La segunda, es que cada tipo de mensaje en la API tiene su propia forma de procesarse dada la naturaleza de la comunicación en la API de TELEGRAM (objetos de JSON). Por dicha razón cada modo de comunicación tiene su propio Handler, esto separa lógicamente la comunicación mediante comandos del texto plano o las callback_queries. Esto implica que para extender las maneras de comunicarse basta con agregar un handler que represente esa manera de comunicación. Actualmente se procesan comandas y callback queries por lo tanto solo existen esos handlers.
    La estructura de un Handler es simple, es un objeto que contiene instancias de las diferentes acciones a realizar y define a si mismo una función handle, que hace el match entre una expresión y la expresión regular que identifica a la misma. Si el match se cumple se llama a la función do_action de la Acción en Cuestión.
    A continuación se muestra como ejemplo el comand Handler

\begin{lstlisting}
    class CommandHandler(Handler):
    start_command = StartCommand()
    help_command = HelpCommand()
    unknown_command = UnknownCommand()
    ...

    def handle(self, expression: str, for_id: int) -> None:

        # expression <-> /start
        if self.start_command.re.match(expression):
            self.start_command.do_action(chat_id=for_id)

        # expression <-> /help
        elif self.help_command.re.match(expression):
            self.help_command.do_action(chat_id=for_id)


\end{lstlisting}

\subsubsection{Actions}
Un tercer aspecto es que se extrapolo el concepto de acción a una clase abstracta Action, utilizando el modulo abc de python. El único compromiso de esta clase es realizar una acción. Y a esta clase la extiende dos clases una es Command y la otra es CallBackQuery. Que agrupan las funcionalidades tipicas de cada forma de comunicación, esto permite al handler instanciar varios Commands o CallBackQueries por ejemplo y llamar do_action en cada una para representar la acción buscada por el usuario.
Esto también permite diseñar la respuesta a cada acción de manera individual ocultando la complejidad del modelo de interacción.


La última modificación es que se creo una clase llamada Objects con el objeto de imitar el comportamiento de los objetos de la API basados en JSON a objetos de python. El gran problema lo presentan los objetos compuestos sobre todo en la distintión de typos, python a ido agregando varias herramientas de typado, pero el standard de JSON carece de ellas y complica modelos de herencia muy extendidos. Por ejemplo un mensaje contine dentro un keyboard y el keyboard a su vez contiene una callback query a realizarse y ser procesada de vuelta por el sistema. Las detecciones a traves de match y regex son muy utles a la hora de procesar el mensaje, pero no tienen el mismo valor a la hora de constuirlos, es por eso, que se diseño un modelo de objetos que pudiera interactuar de manera más sencilla con los objetos de la API de Telegram. Sin embargo, todavía no se logra un modelo completamente funcional que sea lo suficientemente robusto como para usarse. Para la creación de estos objetos se usaron Typed Dictionaries (TypedDict) una nueva libreria de python 3.10.
Estos objetos buscan 3 simplificar 3 procesos: la detección de objetos compuestos y sus funcionalidades correspondientes a cada objeto. La transformación de JSON a python de objetos compuestos. Y por ultimo de python a JSON.
Se propone investigar si usar el modelo de serializers de API rest u otros similares. El principal problema no es la traducción de uno a otro lenguaje, sino la traducción y detección de objetos compuestos.

Como resumen, se pasó de un modelo que contenía toda la lógica de procesamiento de mensajes en la view a uno que separa en capas lógicas cada parte de la interacción, aprovecha modelos de herencia y estandariza el comportamiento esperado en cada fase del procesamiento de información.

Imagen vs modelo anterior actual

% \begin{tabular}{c c}
%     Message -> BOT endpoint
% BOT view :
% # 1
%  If Typeof Comunication1:
%   If Typeof Action1:
%     Action1 code....

%   If Typeof Action2:
%     Action2 code....

%   If Typeof ActionN:
%     ActionN code....
% ...
%  If Typeof Comunication2:
%   If Typeof Action2:
% ...
%  If Typeof ComunicationN:
%     &
%     Message -> BOT endpoint

% Bot view -> Parser(Comunication way)

% Parser -> Handler(Action)

% Handler -> Action.do_action()
% \end{tabular}





Se migró de un modelo no extensible (según la lógica de diseño modular) a uno extensible. Se ordenaron en capas la resolución de mensajes y se modularizó y estandarizó la manera de tomar la acción debida en cada situación.

Nuevas Funcionalidades
Tareas
Algunas de las funcionalidades comprometidas requerían la ejecución de tareas de forma asíncrona. Particularmente las funcionalidades de subscripción, tales como los recordatorios. Ya que se debía levantar una notificación en el momento indicado para cada usuario.
Con este fin, se agregó la librería “celery” para el manejo de tareas en python.
Celery, es un gestor de tareas o cola de tareas y trabaja en base a un broker, eso significa que puede recibir tareas desde diferentes instancias o servicios, y procesaralas de forma eficiente.
La gran ventaja es que para realizar esto se configura una aplicación de celery, esta “entidad” se encarga de enlazar las configuraciones hechas en el código por el desarrollador a un worker. Un worker es una instancia de celery que funciona como un thread o proceso. Entonces celery envía a través del broker las tareas que esten configuradas en una APP a un proceso que las ejecuta. En celery se pueden ejecutar tareas directamente, de forma asíncrona o programadas.
A continuación se explica como se usan tareas para lograr hacer funcionar los recordatorios.
Subscripciones: Una suscripción cómo se explicó en el proceso de diseño es la capacidad que le da el sistema al usuario de elegir de entre una colección de opciones, una o más a las que suscribirse par obtener información relevante en una cierta frecuencia. Para poder entregar estos mensajes en el momento especificado se crean notificaciones y se requiere un proceso de actualización.
Notificaciones :Una Notificación, en en este sistema es una mensaje que debe ser enviado a un usuario en algún momento
Sistema de Suscripciones
A partir del diseño del sistema de suscripciones (modelo x pasos). El desarrollo s hechizo así:
Cuando se crea una suscripción en el sistema este gatilla la creación de una notificación.
En el sistema se programararon tareas recurrentes con celery que revisan la base de datos manera recurrente y en el caso de encontrar una colección de notificaciones que deben enviarse hoy, se envían. 
De este modelo el envío de las notificaciones se realiza por parte del gestor de tareas.
Esto da un comportamiento dual en el que las suscripciones se realizan de manera sincrona y las notificaciones se envía de forma programada.
La configuración de celery es sumamente sencilla ya que se realiza una breve configuración inicial y las tareas simplemente se identifican con @decorators de Python (que son azucar sintáctico que nombra a un wraper para dichas funciones). 
El código queda más o menos así:

\begin{lstlisting}
app = Celery('API')
app.config_from_object('django.conf:settings', namespace='CELERY')
app.autodiscover_tasks()

app.conf.beat_schedule = {
    # Executes every Monday morning at 7:30 a.m.
    'add-every-minute': {
        'task': 'tasks.send_today_notifications',
        'schedule': crontab(minute=1)
    },}

@shared_task
def send_today_notifications():
    notifications = Notification.get_today_notifications()
    messages = [] #[{"text": '', "keyboard": {}}]
    
    for notification in notifications:
        msg = markup_clearner(f'{notification.msg}')
        try:
            notf_susc = notification.subscription
            notf_chat = notf_susc.chat
            print(notf_chat)
        except:
            notf_chat = None
        notf_message = {'text': msg, 'keyboard': {}, 'chat': notf_chat}
        messages.append(notf_message)

    for msg in messages:
        if msg['chat'] is None:
            continue
        async_send(msg['text'], msg['chat'], msg['keyboard'])


\end{lstlisting}

Notas extra sobre el sistema de suscripciones:
Para lograr programar tareas se utiliza un módulo de celery que se ejecuta como un proceso paralelo llamado celery beat. Además los resultados de las tareas y las tareas programadas se guardian en la base de datos. De esta forma hay al menos 2 procesos paralelos en ejecución un worker de la aplicación y beat el programador que hace uso de la db.
\section{}
Nueva arquitectura Física
Diagrama.


La nueva arquitectura cómo se puede apreciar en el diagrama integra:
La Base de Datos (Mongodb):  En la base de datos se almenacenan los datos de autenticación, la información de la aplicación, el contenido de subscripción, las preferencias de los usuarios y las tareas.
Backend Django: Contiene la lógica del servicio de contenido, también configura y programa las tareas (de manera manual una vez). Se comunica a través del broker con la cola de tareas.
Broker de Mensajes (Redis): Sincroniza la la P
API Telegram: Servicio externo proporcionado por telegram que permite la comunicación entre la app y los usuarios del bot (que son por defecto usuarios de telegram).
El Front web: Sirve tanto como plataforma de información como centro de control de para los staf de la mesa de ayuda.
Celery: Maneja las tareas programadas, asíncronas y directas desde la aplicación.
Nueva Arquitectura Lógica
Diagrama

Modulos ya existentes
Process, correspondiente al módulo de procesos descritos anteriormente.
Instances, correspondiente a las instancias de cada proceso.
FAQ, el cual aborda las preguntas frecuentes asociadas a un proceso.
Category, asociado a las categorías de una pregunta. Esta aplicación es utilizada por el bot y se describe con más detalle en la sección 5.3.
Profile, correspondiente al manejo de usuarios(as) de la aplicación Web.
Modulo modificado
Bot, correspondiente a la implementación del bot de Telegram de esta solución. Se añaden los submodulos de: Telegram y task. En tasks, se almacena las nuevas tareas periodicas del sistema, aunque pueden agregarse en cualquier parte del backend. En el modulo de Telegram se integra la nueva lógica de parser, handler, acciones y objetos.
Modulos nuevos
BotUsers, corresponde al manejo de los usuarios(as) del Bot.
Content, correspondiente al manejo de las suscripciones y otras funcionalidades de contenido.
Docu, que añade la documentación del sistema y los procesos realizados
Fixtures, que añade datos de prueba para poblar el sistema.


\subsection{Problemas de compatibilidad}
Djongo
(ODM vs ORM)
Django que es el framework de desarrollo web en el que está desarrollado el projecto funciona con un sistema llamado Object Relationship Mapping, que lo que hace es traducir operaciones d objetos de django a queries en la base de datos relacional. Esto en general era parte de desarrollo de las aplicaciones en frameworks como sping de java, aun es necesario realizar este tipo de adecuaciones, para trabajar con los resultados salientes de la base de datos. Esta funcionalidad clave de django da una enorme simplicidad y versatilidad al código. Por otro lado Mongo es una base de datos no relacional, si bien se puede integrar a python con varias librerías integrarla con el ORM de django no es tan sencillo. De hecho, en general hay conectores a base de datos pero no algo similar al ORM. En ese sentido djongo es un proyecto que logra soslayar esta dificultad, con lo que ellos llaman un ODM un Object Document Mapping. Ahora como todas las operaciones en Mongo son operaciones de documentos y no de tablas, la traducción no siempre es perfecta, y eso implica que cosas como una migración para cambiar el tipo de una tabla por ejemplo no solo no sean necesarias sino imposibles. Ya que mongo no necesita ni tiene un método para cambiar el tipo de tabla, en realidad, nada asegura que un documento dentro de la misa colección tenga el mismo formato que otro, por esto se puede modificar los modelos de django en vivo y el cambio se ve reflejado de manera directa sin migraciones.
Por otro lado para lograr la mayor compatibilidad posible djongo crea un super set al modulo models de django para incluir algunas estructuras interesante como modelos embebidos, arreglos entre otros.
Uno de los grandes problemas es que django por default crea un identificador de tipo int, que se puede reemplazar manualmente por cualquier otro, pero en el caso de djongo se agrega usualmente por temas de compatibilidad, sin embargo, esto no ocurre el 100\% de las veces, de hecho, para todos los modelos nuevos que se crearon en el proyecto para algunos funcionaba y para otros no aleatoriamente, esto causo un error muy complejo de resolver porque fue muy dificil de identificar. Al mismo tiempo complicó la administración de modulos o librerías que funcionaban con el ORM de django como la vista de Admin y Celery.
Para resolverlo se probaron muchas soluciones, pero finalmente, lo que se hizo fue extender la clase Models por default de djongo-django, para que incluyera automáticamente el identificador id que ahora es de tipo uuid. Esto solucionó, los problemas de compatibilidad con el administrador y otros servicios similares.
Para celery y otros servicios, la solución fue no pasar por django, celery se conectó directamente a Mongo como base de datos a traves de una librería experimental, pero la forma de guardar los elementos la hace imposible de manejar con el ORM de django o con las vistas de administrador. Por lo tanto para poder administrar y revisar las tareas se requirió instalar flower. Esta librería permite hacer el seguimiento a los eventos que celery expone (lo que se debe configurar) y eso permite hacer un seguimiento de las tareas de la sesión, para las tareas programadas en otro arranque de flower y celery, se hace necesario revisar directamente en la base de datos, ya que tampoco tienen permanencia los mensajes en el Message Broker en este caso Redis.
La suma de todos estos problemas hizo que fuera difícil configurar el proyecto, hacer trazabilidad de los errores, y una vez configurador entender por qué ciertas líneas de código funcionaban para ciertos objetos en la base de datos y para otros no.
Sumado a esto Celery y djongo son librerías bastantante activas, de hecho Celery cambió completamente su documentación de dominio hace solo unos meses, las ultimas releases son del 2021 aunque han habido convenciones anuales por Varios años. Por otro lado djongo se actualizó de ser una librería a tener una versión de pago para empresas, a dar soporte, incluso ahora se ofrecen otros servicios cloud usando mongo Atlas y demaces.
Esto hace que mantener el proyecto requiera de estar en constante revisión de los recursos utilizados, ya que las dependencias están en constante actualización. Esta fue una de las lecciones más importantes del proyecto, a la vez que uno de los mayores desafíos.
